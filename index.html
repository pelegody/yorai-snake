<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0b0b; color:#eaeaea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }

    /* Wider overall page */
    .wrap { max-width: 1200px; margin: 0 auto; padding: 14px; }

    .topbar { display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .panel { background:#121212; border:1px solid #2a2a2a; border-radius:12px; padding:10px; }

    /* Layout: game big, leaderboard small */
    .row {
      display: grid;
      grid-template-columns: 3fr 1fr;
      gap: 10px;
      align-items: start;
    }
    @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }

    /* Keep canvas fitting the viewport height */
    .game-panel { padding: 10px; }
    canvas {
      background:#050505;
      border:1px solid #2a2a2a;
      border-radius:12px;
      display:block;

      /* key: never overflow vertically */
      width: 100%;
      height: auto;
      max-height: calc(100vh - 210px); /* topbar + padding */
      aspect-ratio: 1 / 1;

      image-rendering: pixelated;
    }

    input, button {
      background:#1a1a1a; color:#eaeaea; border:1px solid #333; border-radius:10px;
      padding:10px 12px; font-size:14px;
    }
    button { cursor:pointer; }
    button:hover { border-color:#555; }
    .muted { color:#a8a8a8; font-size: 13px; }
    .scores { margin:0; padding-left: 18px; font-size: 13px; line-height: 1.3; }
    .kbd { padding:2px 6px; border:1px solid #333; border-bottom-width:2px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
    .status { font-variant-numeric: tabular-nums; }

    .panel.leaderboard { padding: 10px; max-height: 380px; overflow: auto; }

    /* Score always visible + final score overlay */
    .score-pill {
      display:inline-flex;
      align-items:baseline;
      gap:8px;
      padding:6px 10px;
      border:1px solid #2a2a2a;
      border-radius:999px;
      background: rgba(0,0,0,0.25);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .score-pill strong { font-size: 20px; }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.72);
      z-index: 999;
      padding: 16px;
    }
    .overlay.show { display: flex; }
    .overlay-card {
      width: min(520px, 100%);
      background: #121212;
      border: 1px solid #2a2a2a;
      border-radius: 16px;
      padding: 16px;
      text-align: center;
      box-shadow: 0 12px 40px rgba(0,0,0,0.6);
    }
    .final-score {
      font-size: 44px;
      font-weight: 800;
      margin: 10px 0 6px;
      font-variant-numeric: tabular-nums;
    }
    .overlay-actions { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="panel">
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <div><strong>Snake</strong></div>
          <div class="score-pill">Score <strong id="score">0</strong></div>
        </div>
        <div class="muted">
          Controls: <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span>,
          pause <span class="kbd">Space</span>, restart <span class="kbd">R</span>
        </div>
        <div class="muted">
          Bonus: 25% chance after eating food. Lasts 10–20s. Grants <strong>remaining seconds</strong> points. Doesn’t grow snake.
        </div>
      </div>

      <div class="panel" style="min-width: 280px;">
        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <input id="name" maxlength="16" placeholder="Name (for leaderboard)" />
          <button id="startBtn">Start</button>
          <button id="muteBtn">Mute</button>
        </div>
        <div class="muted" id="netStatus">Connecting…</div>
      </div>
    </div>

    <div style="height:10px;"></div>

    <div class="row">
      <div class="panel game-panel">
        <!-- Keep internal resolution moderate; CSS handles fitting -->
        <canvas id="c" width="720" height="720"></canvas>
        <div class="muted" id="bonusStatus" style="margin-top:8px;"></div>
      </div>

      <div class="panel leaderboard">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
          <strong>Top 5 (online)</strong>
          <button id="refreshBtn">Refresh</button>
        </div>
        <ol id="scores" class="scores"></ol>
        <div class="muted">Scores are verified server-side by replaying your run (seed + inputs).</div>
      </div>
    </div>
  </div>

  <!-- Game Over overlay -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-label="Game over">
    <div class="overlay-card">
      <div class="muted">Game over</div>
      <div class="final-score" id="finalScore">0</div>
      <div class="muted" id="finalNote">Submitting score…</div>
      <div class="overlay-actions">
        <button id="playAgainBtn">Play again</button>
        <button id="closeOverlayBtn">Close</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- CONFIG ----------
  const GRID = 24;
  const TICK_MS = 110;
  const BONUS_CHANCE = 0.25;
  const BONUS_MIN = 10;
  const BONUS_MAX = 20;
  const API_BASE = "/.netlify/functions";
  // ---------------------------

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const elScore = document.getElementById("score");
  const elBonusStatus = document.getElementById("bonusStatus");
  const elScores = document.getElementById("scores");
  const elNetStatus = document.getElementById("netStatus");
  const elName = document.getElementById("name");

  const startBtn = document.getElementById("startBtn");
  const refreshBtn = document.getElementById("refreshBtn");
  const muteBtn = document.getElementById("muteBtn");

  const overlay = document.getElementById("overlay");
  const finalScoreEl = document.getElementById("finalScore");
  const finalNoteEl = document.getElementById("finalNote");
  const playAgainBtn = document.getElementById("playAgainBtn");
  const closeOverlayBtn = document.getElementById("closeOverlayBtn");

  // Images
  const imgSnake = new Image(); imgSnake.src = "snake.png";
  const imgFood  = new Image(); imgFood.src  = "food.png";
  const imgBonus = new Image(); imgBonus.src = "bonus.png";
  const hasImg = (img) => img && img.complete && img.naturalWidth > 0;

  // Sounds
  const sEat0 = new Audio("eat0.mp3");
  const sEat1 = new Audio("eat1.mp3");
  const sBonus = new Audio("bonus.mp3");
  const sLose = new Audio("lose.mp3");
  let muted = false;
  let eatFlip = 0;

  function play(sound) {
    if (muted) return;
    try { sound.currentTime = 0; sound.play(); } catch {}
  }

  muteBtn.onclick = () => {
    muted = !muted;
    muteBtn.textContent = muted ? "Unmute" : "Mute";
  };

  // PRNG
  function mulberry32(seed) {
    let a = seed >>> 0;
    return function() {
      a |= 0; a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }

  // ---------- GAME STATE ----------
  let running = false;
  let paused = false;

  let snake = [];
  let dir = {x:1, y:0};
  let pendingDir = null;

  let food = null;
  let bonus = null; // {x,y, expiresTick, totalSec}
  let score = 0;

  let tickHandle = null;
  let tickCount = 0;

  let session = null;
  let rng = null;
  let inputEvents = [];

  // ---------- HELPERS ----------
  function cellSize() { return Math.floor(canvas.width / GRID); }
  function drawCellImage(img, x, y) {
    const cs = cellSize();
    ctx.drawImage(img, x * cs, y * cs, cs, cs);
  }
  function drawCellRect(x, y) {
    const cs = cellSize();
    ctx.fillRect(x * cs, y * cs, cs, cs);
  }
  function eq(a,b){ return a.x===b.x && a.y===b.y; }
  function inBounds(p) { return p.x>=0 && p.x<GRID && p.y>=0 && p.y<GRID; }
  function isOccupied(p){ return snake.some(s => s.x===p.x && s.y===p.y); }

  function randomEmptyCell() {
    for (let i=0;i<200;i++){
      const x = Math.floor(rng() * GRID);
      const y = Math.floor(rng() * GRID);
      const p = {x,y};
      if (!isOccupied(p) && (!food || !eq(p, food)) && (!bonus || !eq(p, bonus))) return p;
    }
    for (let y=0;y<GRID;y++){
      for (let x=0;x<GRID;x++){
        const p = {x,y};
        if (!isOccupied(p) && (!food || !eq(p, food)) && (!bonus || !eq(p, bonus))) return p;
      }
    }
    return null;
  }

  function setDir(newDir) {
    if (newDir.x === -dir.x && newDir.y === -dir.y) return;
    pendingDir = newDir;
  }

  function dirCodeFromVec(v){
    if (v.x===0 && v.y===-1) return "U";
    if (v.x===0 && v.y===1) return "D";
    if (v.x===-1 && v.y===0) return "L";
    if (v.x===1 && v.y===0) return "R";
    return "R";
  }

  function recordInput(code) {
    inputEvents.push({ t: tickCount, d: code });
  }

  // ---------- BONUS ----------
  function maybeSpawnBonus() {
    if (bonus) return;
    if (rng() >= BONUS_CHANCE) return;

    const sec = Math.floor(rng() * (BONUS_MAX - BONUS_MIN + 1)) + BONUS_MIN;
    const pos = randomEmptyCell();
    if (!pos) return;

    const expiresTick = tickCount + Math.ceil((sec * 1000) / TICK_MS);
    bonus = { x: pos.x, y: pos.y, expiresTick, totalSec: sec };
  }

  function bonusRemainingSeconds() {
    if (!bonus) return 0;
    const ticksLeft = bonus.expiresTick - tickCount;
    if (ticksLeft <= 0) return 0;
    return Math.ceil((ticksLeft * TICK_MS) / 1000);
  }

  function setScore(newScore) {
    score = newScore;
    elScore.textContent = String(score);
  }

  // ---------- OVERLAY ----------
  function showGameOverOverlay() {
    finalScoreEl.textContent = String(score);
    finalNoteEl.textContent = "Submitting score…";
    overlay.classList.add("show");
  }
  function hideOverlay() {
    overlay.classList.remove("show");
  }

  function startTicking() {
    if (tickHandle) clearInterval(tickHandle);

    tickHandle = setInterval(() => {
      try {
        step();
      } catch (e) {
        console.error("step crashed:", e);
        running = false;
        paused = false;
        if (tickHandle) clearInterval(tickHandle);
        tickHandle = null;
      }
    }, TICK_MS);
  }

  playAgainBtn.onclick = () => {
    hideOverlay();
    if (session?.seed != null) {
      resetGame(session.seed);
      running = true;
      paused = false;
      startTicking();
    }
  };
  closeOverlayBtn.onclick = hideOverlay;
  overlay.addEventListener("click", (e) => { if (e.target === overlay) hideOverlay(); });

  // ---------- RENDER ----------
  function render() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    const cs = cellSize();

    // grid faint
    ctx.save();
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = "#2a2a2a";
    for (let i=1;i<GRID;i++){
      ctx.beginPath(); ctx.moveTo(i*cs,0); ctx.lineTo(i*cs, canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,i*cs); ctx.lineTo(canvas.width, i*cs); ctx.stroke();
    }
    ctx.restore();

    // food
    if (food) {
      if (hasImg(imgFood)) drawCellImage(imgFood, food.x, food.y);
      else { ctx.fillStyle = "#ff6b6b"; drawCellRect(food.x, food.y); }
    }

    // bonus
    if (bonus) {
      if (hasImg(imgBonus)) drawCellImage(imgBonus, bonus.x, bonus.y);
      else { ctx.fillStyle = "#ffd93d"; drawCellRect(bonus.x, bonus.y); }
    }

    // snake
    for (let i=0;i<snake.length;i++){
      const s = snake[i];
      if (hasImg(imgSnake)) drawCellImage(imgSnake, s.x, s.y);
      else { ctx.fillStyle = i===0 ? "#6ee7b7" : "#34d399"; drawCellRect(s.x, s.y); }
    }

    // status under canvas
    if (bonus) {
      const rem = bonusRemainingSeconds();
      elBonusStatus.textContent = `Bonus active: ${rem}s remaining (worth ${rem} points)`;
    } else {
      elBonusStatus.textContent = paused ? "Paused" : (running ? "" : "Press Start");
    }
  }

  // ---------- GAME LOOP ----------
  function resetGame(seed) {
    rng = mulberry32(seed);

    setScore(0);
    tickCount = 0;
    inputEvents = [];
    eatFlip = 0;

    const mid = Math.floor(GRID/2);
    snake = [{x:mid, y:mid}, {x:mid-1,y:mid}, {x:mid-2,y:mid}, {x:mid-3,y:mid}];
    dir = {x:1,y:0};
    pendingDir = null;

    bonus = null;
    food = randomEmptyCell();

    render();
  }

  function lose() {
    running = false;
    paused = false;
    if (tickHandle) clearInterval(tickHandle);
    tickHandle = null;

    play(sLose);
    elBonusStatus.textContent = "Game over. Press R to restart.";

    showGameOverOverlay();

    submitScore()
      .then((verified) => {
        if (verified != null) finalNoteEl.textContent = `Verified score: ${verified}`;
        else finalNoteEl.textContent = "Submitted.";
      })
      .catch((e) => {
        finalNoteEl.textContent = "Submit failed: " + (e?.message || "unknown");
      });
  }

  function step() {
    if (!running || paused) return;

    tickCount++;

    if (pendingDir) { dir = pendingDir; pendingDir = null; }

    const head = snake[0];
    const next = {x: head.x + dir.x, y: head.y + dir.y};

    if (!inBounds(next)) return lose();

    const willEatFood = food && eq(next, food);
    const willEatBonus = bonus && eq(next, bonus);

    const hitsBody = snake.some((s, idx) =>
      (s.x===next.x && s.y===next.y) && !(idx===snake.length-1 && !willEatFood)
    );
    if (hitsBody) return lose();

    snake.unshift(next);

    if (bonus && tickCount >= bonus.expiresTick) bonus = null;

    if (willEatFood) {
      setScore(score + 1);

      play(eatFlip % 2 === 0 ? sEat0 : sEat1);
      eatFlip++;

      food = randomEmptyCell();
      maybeSpawnBonus();
    } else if (willEatBonus) {
      const rem = bonusRemainingSeconds();
      setScore(score + rem);

      play(sBonus);

      snake.pop();
      bonus = null;
    } else {
      snake.pop();
    }

    render();
  }

  // ---------- INPUT ----------
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (k === " "){
      if (!running) return;
      paused = !paused;
      elBonusStatus.textContent = paused ? "Paused" : "";
      return;
    }
    if (k === "r") {
      e.preventDefault();

      // Remove focus from inputs / overlay buttons
      if (document.activeElement && document.activeElement.blur) {
        document.activeElement.blur();
      }

      // If no session yet, behave like Start
      if (session?.seed == null) {
        startBtn.click();
        return;
      }

      hideOverlay();
      resetGame(session.seed);
      running = true;
      paused = false;
      startTicking();
      return;
    }

    const before = dirCodeFromVec(pendingDir || dir);

    if (k === "arrowup") { e.preventDefault(); setDir({x:0,y:-1}); }
    else if (k === "arrowdown") { e.preventDefault(); setDir({x:0,y:1}); }
    else if (k === "arrowleft") { e.preventDefault(); setDir({x:-1,y:0}); }
    else if (k === "arrowright") { e.preventDefault(); setDir({x:1,y:0}); }
    else return;

    const after = dirCodeFromVec(pendingDir || dir);
    if (after !== before) recordInput(after);
  });

  // ---------- LEADERBOARD ----------
  async function apiGet(path) {
    const r = await fetch(`${API_BASE}${path}`, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }
  async function apiPost(path, body) {
    const r = await fetch(`${API_BASE}${path}`, {
      method: "POST",
      headers: {"content-type":"application/json"},
      body: JSON.stringify(body),
    });
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  function renderTop5(items) {
    elScores.innerHTML = "";
    for (const it of items) {
      const li = document.createElement("li");
      li.textContent = `${it.name} — ${it.score}`;
      elScores.appendChild(li);
    }
  }

  async function refreshTop5() {
    try {
      const data = await apiGet("/top5");
      renderTop5(data.top5 || []);
      elNetStatus.textContent = "Online leaderboard loaded.";
    } catch (e) {
      elNetStatus.textContent = "Leaderboard failed: " + (e?.message || "unknown");
    }
  }

  async function newSession() {
    const name = (elName.value || "").trim().slice(0,16) || "anon";
    const data = await apiPost("/new", { name });
    session = data;
    session.name = name;
    elNetStatus.textContent = "Session ready.";
    return data;
  }

  async function submitScore() {
    if (!session) return null;
    const name = (session?.name || (elName.value || "")).trim().slice(0,16) || "anon";

    const payload = {
      name,
      sessionId: session.sessionId,
      sig: session.sig,
      seed: session.seed,
      tickCount,
      inputs: inputEvents,
    };

    const res = await apiPost("/submit", payload);
    if (res.ok) {
      elNetStatus.textContent = `Submitted. Verified score: ${res.verifiedScore}.`;
      await refreshTop5();
      return res.verifiedScore;
    } else {
      elNetStatus.textContent = `Submit rejected: ${res.reason || "unknown"}`;
      return null;
    }
  }

  // ---------- START ----------
  startBtn.onclick = async () => {
    try {
      elNetStatus.textContent = "Creating session…";
      const s = await newSession();
      hideOverlay();
      resetGame(s.seed);
      running = true;
      paused = false;

      if (tickHandle) clearInterval(tickHandle);
      tickHandle = setInterval(step, TICK_MS);

      render();
    } catch (e) {
      elNetStatus.textContent = "Failed to start session. Is backend deployed?";
    }
  };

  refreshBtn.onclick = () => refreshTop5();

  refreshTop5();
  render();
})();
</script>
</body>
</html>
